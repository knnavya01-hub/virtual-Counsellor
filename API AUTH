"""
Authentication API Endpoints
User registration, login, JWT token management
"""

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from pydantic import BaseModel, EmailStr, Field
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
from typing import Optional
import logging

from app.core.database import get_db
from app.core.config import settings
from app.models.models import User, SubscriptionStatus, UserJourneyStage

logger = logging.getLogger(__name__)
router = APIRouter()

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

# OAuth2 scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/login")

# Request/Response Models

class UserRegister(BaseModel):
    """User registration request"""
    email: EmailStr
    password: str = Field(..., min_length=8)
    age: Optional[int] = Field(None, ge=13, le=120)
    life_context: Optional[str] = Field(None, max_length=2000)
    personal_intro: Optional[str] = Field(None, max_length=2000)

class UserLogin(BaseModel):
    """User login response"""
    access_token: str
    token_type: str = "bearer"
    user: dict

class Token(BaseModel):
    """JWT token"""
    access_token: str
    token_type: str

class UserProfile(BaseModel):
    """User profile response"""
    id: int
    email: str
    age: Optional[int]
    life_context: Optional[str]
    journey_stage: str
    subscription_status: str
    trial_end_date: Optional[datetime]
    created_at: datetime

# Helper Functions

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify password against hash"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash password"""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create JWT access token"""
    to_encode = data.copy()
    
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    
    return encoded_jwt

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> User:
    """
    Dependency: Get current authenticated user from JWT token
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    result = await db.execute(select(User).where(User.id == user_id))
    user = result.scalar_one_or_none()
    
    if user is None:
        raise credentials_exception
    
    # Update last login
    user.last_login = datetime.utcnow()
    await db.commit()
    
    return user

# Endpoints

@router.post("/register", response_model=UserLogin, status_code=status.HTTP_201_CREATED)
async def register_user(
    user_data: UserRegister,
    db: AsyncSession = Depends(get_db)
):
    """
    Register a new user
    
    Automatically starts free trial period
    """
    
    # Check if email already exists
    result = await db.execute(select(User).where(User.email == user_data.email))
    existing_user = result.scalar_one_or_none()
    
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Email already registered"
        )
    
    # Create new user
    trial_end = datetime.utcnow() + timedelta(days=settings.FREE_TRIAL_DAYS)
    
    new_user = User(
        email=user_data.email,
        hashed_password=get_password_hash(user_data.password),
        age=user_data.age,
        life_context=user_data.life_context,
        personal_intro=user_data.personal_intro,
        journey_stage=UserJourneyStage.TRIGGERED,
        subscription_status=SubscriptionStatus.FREE_TRIAL,
        trial_start_date=datetime.utcnow(),
        subscription_end_date=trial_end,
        last_login=datetime.utcnow()
    )
    
    db.add(new_user)
    await db.commit()
    await db.refresh(new_user)
    
    # Create access token
    access_token = create_access_token(
        data={"sub": new_user.id}
    )
    
    logger.info(f"New user registered: {new_user.email} (ID: {new_user.id})")
    
    return UserLogin(
        access_token=access_token,
        token_type="bearer",
        user={
            "id": new_user.id,
            "email": new_user.email,
            "journey_stage": new_user.journey_stage.value,
            "subscription_status": new_user.subscription_status.value,
            "trial_end_date": trial_end.isoformat()
        }
    )


@router.post("/login", response_model=UserLogin)
async def login_user(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    """
    Login user and return JWT token
    
    Username field should contain email
    """
    
    # Find user by email
    result = await db.execute(select(User).where(User.email == form_data.username))
    user = result.scalar_one_or_none()
    
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Check subscription status
    if user.subscription_status == SubscriptionStatus.EXPIRED:
        # Check if trial has expired
        if user.subscription_end_date and user.subscription_end_date < datetime.utcnow():
            logger.warning(f"User {user.id} login with expired subscription")
    
    # Create access token
    access_token = create_access_token(
        data={"sub": user.id}
    )
    
    # Update last login
    user.last_login = datetime.utcnow()
    await db.commit()
    
    logger.info(f"User login: {user.email} (ID: {user.id})")
    
    return UserLogin(
        access_token=access_token,
        token_type="bearer",
        user={
            "id": user.id,
            "email": user.email,
            "journey_stage": user.journey_stage.value if user.journey_stage else "searching",
            "subscription_status": user.subscription_status.value,
            "subscription_end_date": user.subscription_end_date.isoformat() if user.subscription_end_date else None
        }
    )


@router.get("/profile", response_model=UserProfile)
async def get_profile(
    current_user: User = Depends(get_current_user)
):
    """Get current user's profile"""
    
    return UserProfile(
        id=current_user.id,
        email=current_user.email,
        age=current_user.age,
        life_context=current_user.life_context,
        journey_stage=current_user.journey_stage.value if current_user.journey_stage else "searching",
        subscription_status=current_user.subscription_status.value,
        trial_end_date=current_user.subscription_end_date,
        created_at=current_user.created_at
    )


@router.put("/profile")
async def update_profile(
    age: Optional[int] = None,
    life_context: Optional[str] = None,
    personal_intro: Optional[str] = None,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update user profile"""
    
    if age is not None:
        current_user.age = age
    if life_context is not None:
        current_user.life_context = life_context
    if personal_intro is not None:
        current_user.personal_intro = personal_intro
    
    current_user.updated_at = datetime.utcnow()
    await db.commit()
    
    return {
        "message": "Profile updated successfully",
        "user": {
            "id": current_user.id,
            "email": current_user.email,
            "age": current_user.age
        }
    }


@router.post("/verify-token")
async def verify_token(
    current_user: User = Depends(get_current_user)
):
    """Verify if token is valid"""
    
    return {
        "valid": True,
        "user_id": current_user.id,
        "email": current_user.email
    }
