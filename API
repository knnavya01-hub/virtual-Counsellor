"""
Wisdom API Endpoints
Main endpoint for getting spiritual guidance
"""

from fastapi import APIRouter, Depends, HTTPException, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import BaseModel, Field
from typing import Optional, List
from datetime import datetime
import logging

from app.core.database import get_db
from app.services.wisdom_service import WisdomService
from app.services.memory_service import MemoryService
from app.models.models import User, Conversation, CrisisLog
from app.api.v1.auth import get_current_user
from sqlalchemy import select

logger = logging.getLogger(__name__)
router = APIRouter()

# Request/Response Models

class WisdomRequest(BaseModel):
    """Request for wisdom guidance"""
    query: str = Field(..., min_length=3, max_length=5000, description="User's question or situation")
    input_mode: str = Field(default="text", description="Input mode: 'text' or 'voice'")
    detected_emotion: Optional[str] = Field(None, description="User's current emotion")
    include_visuals: bool = Field(default=True, description="Generate visual scene prompts")

class ScriptureCitation(BaseModel):
    """Scripture reference"""
    source_name: str
    chapter: Optional[str]
    verse_number: Optional[str]
    english_translation: str
    themes: List[str]

class QualityScores(BaseModel):
    """Response quality metrics"""
    faithfulness: float
    relevance: float
    coherence: float
    hallucination_score: float

class VisualPrompt(BaseModel):
    """Visual scene prompt"""
    description: str
    style: str

class WisdomResponse(BaseModel):
    """Response with spiritual wisdom"""
    type: str  # "wisdom" or "crisis"
    wisdom_text: Optional[str] = None
    scriptures_cited: Optional[List[ScriptureCitation]] = None
    quality_scores: Optional[QualityScores] = None
    visual_prompts: Optional[List[VisualPrompt]] = None
    response_time_seconds: float
    personalization: Optional[dict] = None
    
    # Crisis response fields
    crisis_response: Optional[dict] = None
    confidence: Optional[float] = None
    detected_keywords: Optional[List[str]] = None

# Endpoints

@router.post("/ask", response_model=WisdomResponse)
async def ask_wisdom(
    request: WisdomRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
    background_tasks: BackgroundTasks = None
):
    """
    Main endpoint: Ask for spiritual wisdom
    
    This endpoint:
    1. Detects crisis situations
    2. Retrieves relevant scriptures (RAG)
    3. Generates personalized wisdom response
    4. Returns visual prompts for scene generation
    """
    
    start_time = datetime.utcnow()
    
    try:
        # Initialize services
        wisdom_service = WisdomService()
        memory_service = MemoryService()
        
        # Get user profile
        user_profile = {
            "journey_stage": current_user.journey_stage.value if current_user.journey_stage else "searching",
            "age": current_user.age,
            "life_context": current_user.life_context,
            "preferred_themes": current_user.preferred_themes or [],
            "country": "international"  # TODO: Get from user profile
        }
        
        # Get conversation history for context
        history_result = await db.execute(
            select(Conversation)
            .where(Conversation.user_id == current_user.id)
            .order_by(Conversation.created_at.desc())
            .limit(5)
        )
        conversation_history = [
            {
                "user_query": c.user_query,
                "ai_response": c.ai_response,
                "timestamp": c.created_at.isoformat()
            }
            for c in history_result.scalars().all()
        ]
        
        # Get wisdom response
        wisdom_result = await wisdom_service.get_wisdom(
            user_query=request.query,
            user_id=current_user.id,
            user_profile=user_profile,
            conversation_history=conversation_history
        )
        
        # Handle crisis response
        if wisdom_result["type"] == "crisis":
            # Log crisis event in background
            background_tasks.add_task(
                log_crisis_event,
                db,
                current_user.id,
                request.query,
                wisdom_result["confidence"],
                wisdom_result["detected_keywords"]
            )
            
            return WisdomResponse(
                type="crisis",
                crisis_response=wisdom_result["crisis_response"],
                confidence=wisdom_result["confidence"],
                detected_keywords=wisdom_result["detected_keywords"],
                response_time_seconds=wisdom_result.get("response_time_seconds", 0)
            )
        
        # Save conversation to DB
        conversation = Conversation(
            user_id=current_user.id,
            user_query=request.query,
            user_emotion=request.detected_emotion,
            input_mode=request.input_mode,
            ai_response=wisdom_result["wisdom_text"],
            scriptures_cited=wisdom_result["scriptures_cited"],
            response_time_seconds=wisdom_result["response_time_seconds"],
            conversation_context={"memory": wisdom_result.get("personalization")},
            user_journey_snapshot=user_profile
        )
        db.add(conversation)
        await db.commit()
        
        # Memory consolidation in background (every N conversations)
        background_tasks.add_task(
            memory_service.consolidate_memory,
            current_user.id,
            db
        )
        
        # Build response
        response_time = (datetime.utcnow() - start_time).total_seconds()
        
        return WisdomResponse(
            type="wisdom",
            wisdom_text=wisdom_result["wisdom_text"],
            scriptures_cited=[
                ScriptureCitation(**s) for s in wisdom_result["scriptures_cited"]
            ],
            quality_scores=QualityScores(**wisdom_result["quality_scores"]),
            visual_prompts=[
                VisualPrompt(**v) for v in wisdom_result["visual_prompts"]
            ] if request.include_visuals else None,
            response_time_seconds=response_time,
            personalization=wisdom_result.get("personalization")
        )
        
    except Exception as e:
        logger.error(f"Wisdom endpoint error: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Failed to generate wisdom response")


async def log_crisis_event(
    db: AsyncSession,
    user_id: int,
    message: str,
    confidence: float,
    keywords: List[str]
):
    """Background task: Log crisis event"""
    try:
        crisis_log = CrisisLog(
            user_id=user_id,
            user_message=message,
            crisis_score=confidence,
            detected_keywords=keywords,
            crisis_response_sent="Crisis intervention message displayed",
            helplines_displayed=list(settings.CRISIS_HELPLINES.values())
        )
        db.add(crisis_log)
        await db.commit()
        logger.info(f"Crisis event logged for user {user_id}")
    except Exception as e:
        logger.error(f"Failed to log crisis event: {e}")


@router.get("/conversation-history")
async def get_conversation_history(
    limit: int = 10,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's conversation history"""
    
    result = await db.execute(
        select(Conversation)
        .where(Conversation.user_id == current_user.id)
        .order_by(Conversation.created_at.desc())
        .limit(limit)
    )
    conversations = result.scalars().all()
    
    return {
        "conversations": [
            {
                "id": c.id,
                "user_query": c.user_query,
                "ai_response": c.ai_response,
                "emotion": c.user_emotion,
                "created_at": c.created_at.isoformat(),
                "scriptures_count": len(c.scriptures_cited) if c.scriptures_cited else 0
            }
            for c in conversations
        ]
    }


@router.get("/journey-analysis")
async def get_journey_analysis(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get user's spiritual journey analysis"""
    
    memory_service = MemoryService()
    analysis = await memory_service.analyze_user_journey(current_user.id, db)
    
    return {
        "user_id": current_user.id,
        "analysis": analysis,
        "current_stage": current_user.journey_stage.value if current_user.journey_stage else "searching"
    }
